# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @name cppBASMastersample
#'
#' @title cppBASMastersample
#'
#' @description A placeholder for now.
#'
#' @returns Nothing.
NULL

#' @export
cppBASMastersample <- function() {
    invisible(.Call(`_uc511_cppBASMastersample`))
}

#' @name SolveCongruence
#'
#' @title Solve system of linear congruence from HIP paper to order HIP boxes.
#'
#' @description See page 5 of Robertson et al. 2018 Halton Iterative Partitioning.
#' This is essentially an internal function and shouldn't be worried about.
#'
#' @param A Matrix that is in numeric for computational reasons but is the a_i solutions for all HIP boxes.
#' @param base Co-prime Base but generally for BAS work it is 2 or 3.
#' @param J Integer of 2 values that represent the numbers 2^J1, 3^J2.
#'
#' @returns A numeric vector.
#'
#' @export
SolveCongruence <- function(A, base, J) {
    .Call(`_uc511_SolveCongruence`, A, base, J)
}

#' @name GetBoxIndices
#'
#' @title Fast Implementation of finding x and y order numbers
#'
#' @description Fast Implementation of finding x and y order numbers to feed into the linear congruence equation.
#' This solves equation for a_i in the HIP paper.
#' This is essentially an internal function and shouldn't be worried about.
#'
#' @param lxy A Matrix of lower x y coordinates of a Halton Box inside the unit box.
#' @param base Co-prime Base but generally for BAS work it is 2 or 3.
#' @param J Integer of 2 values that represent the numbers 2^J1, 3^J2.
#' @return A matrix of box indices
#'
#' @export
GetBoxIndices <- function(lxy, base, J) {
    .Call(`_uc511_GetBoxIndices`, lxy, base, J)
}

#' @name cppHaltonSeq
#'
#' @title Draw Halton Sequence values for a single dimension.
#'
#' @description Note that this was borrowed from the Internet and is not my implementation.
#'
#' @param k An integer for the starting index k >= 0.
#' @param base Co-prime Base but generally for BAS work it is 2 or 3.
#' @param n Number of samples to draw.
#' @return A Halton sequence of size n.
#'
#' @examples
#' uc511::cppHaltonSeq(k = 0, base = 2, n = 10)
#'
#' @export
cppHaltonSeq <- function(k, base, n) {
    .Call(`_uc511_cppHaltonSeq`, k, base, n)
}

#' @name compareBoxesBoxInit
#'
#' @title title.
#'
#' @description description.
#'
#' @param boxes bla.
#' @param boxInit bla.
#' @param intB bla.
#' @return something
#'
#' @export
compareBoxesBoxInit <- function(boxes, boxInit, intB) {
    .Call(`_uc511_compareBoxesBoxInit`, boxes, boxInit, intB)
}

#' @name cppProductPoweredElements
#'
#' @title Raise each element in a vector by a corresponding power provided in another vector,
#'        then return the product of all the results.
#'
#' @description Raise each element in a vector by a corresponding power provided in another vector,
#'        then return the product of all the results.
#'
#' @param   J           A numeric vector of values with which to raise the corresponding
#'                      element in bases to.
#' @param   bases       A numeric vector containing values to raised to by the corresponding
#'                      powers in J
#' @param   numElements The number of elements in the numeric vector bases.
#'
#' @return The product of all the powers.
#'
#' @examples
#' # calculate the product of the powered elements
#' uc511::cppProductPoweredElements(c(1, 2, 3), c(3, 2, 1), 3)
#'
#' @export
cppProductPoweredElements <- function(J, bases, numElements) {
    .Call(`_uc511_cppProductPoweredElements`, J, bases, numElements)
}

#' @name cppWhere2Start
#'
#' @title Internal function to find the ordering of the first box according to the random seed.
#'
#' @description This is a function to find which Halton Box the initial BAS point from the Master Sample falls into and
#' thus use it to order the remaining boxes based on the initial. It also helps us tracks
#' the master sample index as we skip boxes that have no resource.
#'
#' @param J Definition for the number of grid cells of Halton frame.
#' @param seeds Master Sample random seed.
#' @param bases Co-prime bases should really always be 2,3
#' @param boxes ordering of boxes that have been clipped to be reordered according to the master sample seed.
#'
#' @returns vector of reordered Halton indices.
#'
#' @export
cppWhere2Start <- function(J, seeds, bases, boxes) {
    .Call(`_uc511_cppWhere2Start`, J, seeds, bases, boxes)
}

#' @name log_a_to_base_b
#'
#' @title Compute the log of a to base b.
#'
#' @description Compute the log of a to base b.
#'
#' @param   a       Integer to find the log to base b of.
#' @param   b       Base
#'
#' @return The log of a to base b.
#'
#' @examples
#' # calculate log of a to base b.
#' log_a_to_base_b(2, 4)
#'
#' @export
log_a_to_base_b <- function(a, b) {
    .Call(`_uc511_log_a_to_base_b`, a, b)
}

#' @name cppRSHalton
#'
#' @title Generate numbers from a Halton Sequence with a random start
#'
#' @description For efficiency, this function can generate points along a random start Halton Sequence for
#' predefined Halton.
#'
#' @param n Number of points required
#' @param seeds Random starting point in each dimension
#' @param bases Co-prime base for the Halton Sequence
#' @param boxes Halton boxes that points are required to be generated in
#' @param J Defines the Halton frame, and relates to the number of boxes used.
#'
#' @return Matrix with the columns, order of point, x in [0,1) and y in [0,1)
#'
#' @examples
#' # First 10 points in the Halton Sequence for base 2,3
#' uc511::cppRSHalton(n = 10)
#' # First 10 points in the Halton Sequence for base 2,3 with
#' # starting point at the 15th and 22nd index.
#' uc511::cppRSHalton(n = 10, seeds = c(14, 21))
#'
#' @export
cppRSHalton <- function(n = 10L, seeds = as.integer( c()), bases = as.numeric( c()), boxes = as.numeric( c()), J = as.numeric( c())) {
    .Call(`_uc511_cppRSHalton`, n, seeds, bases, boxes, J)
}

