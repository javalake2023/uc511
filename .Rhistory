i <- 0
while (pts_in_intersection < n){
# keep going until we have found the required number of points
# create halton frame
hf_ <- uc511::HaltonFrame(J = c(3+i, 2+i), bases = c(2, 3))
# process points returned.
pts <- hf_$halton_frame
pts <- cbind(seq(1, dim(pts)[1]), pts)
#
bb <- sf::st_as_sfc(sf::st_bbox(shp.ashb))
cntrd <- sf::st_centroid(bb)
bb.rot <- (bb - cntrd) * rot(0) + cntrd
bb.new <- sf::st_as_sfc(sf::st_bbox(bb.rot))
#
attr(bb.new, "rotation") <- 0
attr(bb.new, "centroid") <- sf::st_coordinates(cntrd)
pts.shp <- uc511::rotate.scale.coords(coords = pts, bb = bb.new)
# replace the CRS (or set), st_intersection needs both objects with the same CRS.
sf::st_crs(shp.ashb) <- 4167 # try st_transform on this first?
sf::st_crs(pts.shp) <- 4167
# make the assumption (that the attribute is constant throughout the geometry) explicit# make the assumption (that the attribute is constant throughout the geometry)
st_agr(shp.ashb) <- "constant"
st_agr(pts.shp) <- "constant"
diff_ <- sf::st_intersection(shp.ashb, pts.shp)
pts_in_intersection <- lengths(diff_$geometry)
i <- i + 1
}
# number of points wanted.
n <- 100
# number of points currently in the area of interest.
pts_in_intersection <- 0
# initialise
i <- 0
while (pts_in_intersection < n){
# keep going until we have found the required number of points
# create halton frame
hf_ <- uc511::HaltonFrame(J = c(3+i, 2+i), bases = c(2, 3))
# process points returned.
pts <- hf_$halton_frame
pts <- cbind(seq(1, dim(pts)[1]), pts)
#
bb <- sf::st_as_sfc(sf::st_bbox(shp.ashb))
cntrd <- sf::st_centroid(bb)
bb.rot <- (bb - cntrd) * rot(0) + cntrd
bb.new <- sf::st_as_sfc(sf::st_bbox(bb.rot))
#
attr(bb.new, "rotation") <- 0
attr(bb.new, "centroid") <- sf::st_coordinates(cntrd)
pts.shp <- uc511::rotate.scale.coords(coords = pts, bb = bb.new)
# replace the CRS (or set), st_intersection needs both objects with the same CRS.
sf::st_crs(shp.ashb) <- 4167 # try st_transform on this first?
sf::st_crs(pts.shp) <- 4167
# make the assumption (that the attribute is constant throughout the geometry) explicit# make the assumption (that the attribute is constant throughout the geometry)
sf::st_agr(shp.ashb) <- "constant"
sf::st_agr(pts.shp) <- "constant"
diff_ <- sf::st_intersection(shp.ashb, pts.shp)
pts_in_intersection <- lengths(diff_$geometry)
i <- i + 1
}
# number of points wanted.
n <- 100
# number of points currently in the area of interest.
pts_in_intersection <- 0
# initialise
i <- 0
while (pts_in_intersection < n){
# keep going until we have found the required number of points
# create halton frame
hf_ <- uc511::HaltonFrame(J = c(3+i, 2+i), bases = c(2, 3))
# process points returned.
pts <- hf_$halton_frame
pts <- cbind(seq(1, dim(pts)[1]), pts)
#
bb <- sf::st_as_sfc(sf::st_bbox(shp.ashb))
cntrd <- sf::st_centroid(bb)
bb.rot <- (bb - cntrd) * rot(0) + cntrd
bb.new <- sf::st_as_sfc(sf::st_bbox(bb.rot))
#
attr(bb.new, "rotation") <- 0
attr(bb.new, "centroid") <- sf::st_coordinates(cntrd)
pts.shp <- uc511::rotate.scale.coords(coords = pts, bb = bb.new)
# replace the CRS (or set), st_intersection needs both objects with the same CRS.
sf::st_crs(shp.ashb) <- 4167 # try st_transform on this first?
sf::st_crs(pts.shp) <- 4167
# make the assumption (that the attribute is constant throughout the geometry) explicit# make the assumption (that the attribute is constant throughout the geometry)
#sf::st_agr(shp.ashb) <- "constant"
#sf::st_agr(pts.shp) <- "constant"
diff_ <- sf::st_intersection(st_geometry(shp.ashb), st_geometry(pts.shp))
pts_in_intersection <- lengths(diff_$geometry)
i <- i + 1
}
# number of points wanted.
n <- 100
# number of points currently in the area of interest.
pts_in_intersection <- 0
# initialise
i <- 0
while (pts_in_intersection < n){
# keep going until we have found the required number of points
# create halton frame
hf_ <- uc511::HaltonFrame(J = c(3+i, 2+i), bases = c(2, 3))
# process points returned.
pts <- hf_$halton_frame
pts <- cbind(seq(1, dim(pts)[1]), pts)
#
bb <- sf::st_as_sfc(sf::st_bbox(shp.ashb))
cntrd <- sf::st_centroid(bb)
bb.rot <- (bb - cntrd) * rot(0) + cntrd
bb.new <- sf::st_as_sfc(sf::st_bbox(bb.rot))
#
attr(bb.new, "rotation") <- 0
attr(bb.new, "centroid") <- sf::st_coordinates(cntrd)
pts.shp <- uc511::rotate.scale.coords(coords = pts, bb = bb.new)
# replace the CRS (or set), st_intersection needs both objects with the same CRS.
sf::st_crs(shp.ashb) <- 4167 # try st_transform on this first?
sf::st_crs(pts.shp) <- 4167
# make the assumption (that the attribute is constant throughout the geometry) explicit# make the assumption (that the attribute is constant throughout the geometry)
#sf::st_agr(shp.ashb) <- "constant"
#sf::st_agr(pts.shp) <- "constant"
diff_ <- sf::st_intersection(sf::st_geometry(shp.ashb), sf::st_geometry(pts.shp))
pts_in_intersection <- lengths(diff_$geometry)
i <- i + 1
}
# number of points wanted.
n <- 100
# number of points currently in the area of interest.
pts_in_intersection <- 0
# initialise
i <- 0
while (pts_in_intersection <= n){
# keep going until we have found the required number of points
# create halton frame
hf_ <- uc511::HaltonFrame(J = c(3+i, 2+i), bases = c(2, 3))
# process points returned.
pts <- hf_$halton_frame
pts <- cbind(seq(1, dim(pts)[1]), pts)
#
bb <- sf::st_as_sfc(sf::st_bbox(shp.ashb))
cntrd <- sf::st_centroid(bb)
bb.rot <- (bb - cntrd) * rot(0) + cntrd
bb.new <- sf::st_as_sfc(sf::st_bbox(bb.rot))
#
attr(bb.new, "rotation") <- 0
attr(bb.new, "centroid") <- sf::st_coordinates(cntrd)
pts.shp <- uc511::rotate.scale.coords(coords = pts, bb = bb.new)
# replace the CRS (or set), st_intersection needs both objects with the same CRS.
sf::st_crs(shp.ashb) <- 4167
sf::st_crs(pts.shp) <- 4167
# make the assumption (that the attribute is constant throughout the geometry) explicit# make the assumption (that the attribute is constant throughout the geometry)
#sf::st_agr(shp.ashb) <- "constant"
#sf::st_agr(pts.shp) <- "constant"
diff_ <- sf::st_intersection(shp.ashb, pts.shp)
pts_in_intersection <- lengths(diff_$geometry)
i <- i + 1
}
# number of points wanted.
n <- 400
# number of points currently in the area of interest.
pts_in_intersection <- 0
# initialise
i <- 0
while (pts_in_intersection <= n){
# keep going until we have found the required number of points
# create halton frame
hf_ <- uc511::HaltonFrame(J = c(3+i, 2+i), bases = c(2, 3))
# process points returned.
pts <- hf_$halton_frame
pts <- cbind(seq(1, dim(pts)[1]), pts)
#
bb <- sf::st_as_sfc(sf::st_bbox(shp.ashb))
cntrd <- sf::st_centroid(bb)
bb.rot <- (bb - cntrd) * rot(0) + cntrd
bb.new <- sf::st_as_sfc(sf::st_bbox(bb.rot))
#
attr(bb.new, "rotation") <- 0
attr(bb.new, "centroid") <- sf::st_coordinates(cntrd)
pts.shp <- uc511::rotate.scale.coords(coords = pts, bb = bb.new)
# replace the CRS (or set), st_intersection needs both objects with the same CRS.
sf::st_crs(shp.ashb) <- 4167
sf::st_crs(pts.shp) <- 4167
# make the assumption (that the attribute is constant throughout the geometry) explicit# make the assumption (that the attribute is constant throughout the geometry)
#sf::st_agr(shp.ashb) <- "constant"
#sf::st_agr(pts.shp) <- "constant"
diff_ <- sf::st_intersection(shp.ashb, pts.shp)
pts_in_intersection <- lengths(diff_$geometry)
i <- i + 1
}
#
msg <- "uc511(HaltonFrame) %s samples found in %s iterations, last used J1=%s and J2=%s."
msgs <- sprintf(msg, pts_in_intersection, i, 3+i, 2+i)
message(msgs)
# number of points wanted.
n <- 338
# number of points currently in the area of interest.
pts_in_intersection <- 0
# initialise
i <- 0
while (pts_in_intersection <= n){
# keep going until we have found the required number of points
# create halton frame
hf_ <- uc511::HaltonFrame(J = c(3+i, 2+i), bases = c(2, 3))
# process points returned.
pts <- hf_$halton_frame
pts <- cbind(seq(1, dim(pts)[1]), pts)
#
bb <- sf::st_as_sfc(sf::st_bbox(shp.ashb))
cntrd <- sf::st_centroid(bb)
bb.rot <- (bb - cntrd) * rot(0) + cntrd
bb.new <- sf::st_as_sfc(sf::st_bbox(bb.rot))
#
attr(bb.new, "rotation") <- 0
attr(bb.new, "centroid") <- sf::st_coordinates(cntrd)
pts.shp <- uc511::rotate.scale.coords(coords = pts, bb = bb.new)
# replace the CRS (or set), st_intersection needs both objects with the same CRS.
sf::st_crs(shp.ashb) <- 4167
sf::st_crs(pts.shp) <- 4167
# make the assumption (that the attribute is constant throughout the geometry) explicit# make the assumption (that the attribute is constant throughout the geometry)
#sf::st_agr(shp.ashb) <- "constant"
#sf::st_agr(pts.shp) <- "constant"
diff_ <- sf::st_intersection(shp.ashb, pts.shp)
pts_in_intersection <- lengths(diff_$geometry)
i <- i + 1
}
#
msg <- "uc511(HaltonFrame) %s samples found in %s iterations, last used J1=%s and J2=%s."
msgs <- sprintf(msg, pts_in_intersection, i, 3+i, 2+i)
message(msgs)
# number of points wanted.
n <- 337
# number of points currently in the area of interest.
pts_in_intersection <- 0
# initialise
i <- 0
while (pts_in_intersection <= n){
# keep going until we have found the required number of points
# create halton frame
hf_ <- uc511::HaltonFrame(J = c(3+i, 2+i), bases = c(2, 3))
# process points returned.
pts <- hf_$halton_frame
pts <- cbind(seq(1, dim(pts)[1]), pts)
#
bb <- sf::st_as_sfc(sf::st_bbox(shp.ashb))
cntrd <- sf::st_centroid(bb)
bb.rot <- (bb - cntrd) * rot(0) + cntrd
bb.new <- sf::st_as_sfc(sf::st_bbox(bb.rot))
#
attr(bb.new, "rotation") <- 0
attr(bb.new, "centroid") <- sf::st_coordinates(cntrd)
pts.shp <- uc511::rotate.scale.coords(coords = pts, bb = bb.new)
# replace the CRS (or set), st_intersection needs both objects with the same CRS.
sf::st_crs(shp.ashb) <- 4167
sf::st_crs(pts.shp) <- 4167
# make the assumption (that the attribute is constant throughout the geometry) explicit# make the assumption (that the attribute is constant throughout the geometry)
#sf::st_agr(shp.ashb) <- "constant"
#sf::st_agr(pts.shp) <- "constant"
diff_ <- sf::st_intersection(shp.ashb, pts.shp)
pts_in_intersection <- lengths(diff_$geometry)
i <- i + 1
}
#
msg <- "uc511(HaltonFrame) %s samples found in %s iterations, last used J1=%s and J2=%s."
msgs <- sprintf(msg, pts_in_intersection, i, 3+i, 2+i)
message(msgs)
library(uc511)
# number of points wanted.
n <- 337
# NEW-ONE
hf_ <- uc511::HaltonFrame(n = n,
J = c(3+i, 2+i),
bases = c(2, 3),
shapefile = shp.ashb,
crs = 4167)
# get a shape file
shp_file1 <- "P:/Downloads/uc511_shiny/gadm36_NZL_shp/gadm36_NZL_2.shp"
shp_file1 <- "/home/phil/uc511shiny/gadm36_NZL_shp/gadm36_NZL_2.shp"
xx1 <- sf::read_sf(shp_file1, stringsAsFactors = TRUE) # read-in shapefile
shp.ashb <- xx1[xx1$NAME_2 == "Ashburton",]
# number of points wanted.
n <- 337
# NEW-ONE
hf_ <- uc511::HaltonFrame(n = n,
J = c(3+i, 2+i),
bases = c(2, 3),
shapefile = shp.ashb,
crs = 4167)
# NEW-ONE
hf_ <- uc511::HaltonFrame(n = n,
J = c(3, 2),
bases = c(2, 3),
shapefile = shp.ashb,
crs = 4167)
# number of points wanted.
n <- 337
# number of points currently in the area of interest.
pts_in_intersection <- 0
# initialise
i <- 0
while (pts_in_intersection <= n){
# keep going until we have found the required number of points
# create halton frame
hf_ <- uc511::HaltonFrame(J = c(3+i, 2+i), bases = c(2, 3))
# process points returned.
pts <- hf_$halton_frame
pts <- cbind(seq(1, dim(pts)[1]), pts)
#
bb <- sf::st_as_sfc(sf::st_bbox(shp.ashb))
cntrd <- sf::st_centroid(bb)
bb.rot <- (bb - cntrd) * rot(0) + cntrd
bb.new <- sf::st_as_sfc(sf::st_bbox(bb.rot))
#
attr(bb.new, "rotation") <- 0
attr(bb.new, "centroid") <- sf::st_coordinates(cntrd)
pts.shp <- uc511::rotate.scale.coords(coords = pts, bb = bb.new)
# replace the CRS (or set), st_intersection needs both objects with the same CRS.
sf::st_crs(shp.ashb) <- 4167
sf::st_crs(pts.shp) <- 4167
# make the assumption (that the attribute is constant throughout the geometry) explicit# make the assumption (that the attribute is constant throughout the geometry)
#sf::st_agr(shp.ashb) <- "constant"
#sf::st_agr(pts.shp) <- "constant"
diff_ <- sf::st_intersection(shp.ashb, pts.shp)
pts_in_intersection <- lengths(diff_$geometry)
i <- i + 1
}
# Test_Halton_Frame_V2.r
library(uc511)
shp_file1 <- "/home/phil/uc511shiny/gadm36_NZL_shp/gadm36_NZL_2.shp"
xx1 <- sf::read_sf(shp_file1, stringsAsFactors = TRUE) # read-in shapefile
shp.ashb <- xx1[xx1$NAME_2 == "Ashburton",]
# number of points wanted.
n <- 337
# NEW-ONE
hf_ <- uc511::HaltonFrame(n = n,
J = c(3, 2),
bases = c(2, 3),
shapefile = shp.ashb,
crs = 4167)
library(uc511)
# NEW-ONE
N <- 337
hf_ <- uc511::HaltonFrame(n = n,
J = c(3, 2),
bases = c(2, 3),
shapefile = shp.ashb,
crs = 4167)
# create/update files in man directory
devtools::document()
library(uc511)
# NEW-ONE
n <- 337
hf_ <- uc511::HaltonFrame(n = n,
J = c(3, 2),
bases = c(2, 3),
shapefile = shp.ashb,
crs = 4167)
shp_file1 <- "/home/phil/uc511shiny/gadm36_NZL_shp/gadm36_NZL_2.shp"
xx1 <- sf::read_sf(shp_file1, stringsAsFactors = TRUE) # read-in shapefile
shp.ashb <- xx1[xx1$NAME_2 == "Ashburton",]
# number of points wanted.
n <- 337
hf_ <- uc511::HaltonFrame(n = n,
J = c(3, 2),
bases = c(2, 3),
shapefile = shp.ashb,
crs = 4167)
#
#pts <- hf_$halton_seq
pts <- hf_$halton_frame
pts <- cbind(seq(1, dim(pts)[1]), pts)
#
bb <- sf::st_as_sfc(sf::st_bbox(shp.ashb))
cntrd <- sf::st_centroid(bb)
bb.rot <- (bb - cntrd) * rot(0) + cntrd
bb.new <- sf::st_as_sfc(sf::st_bbox(bb.rot))
#
attr(bb.new, "rotation") <- 0
attr(bb.new, "centroid") <- sf::st_coordinates(cntrd)
pts.shp <- uc511::rotate.scale.coords(coords = pts, bb = bb.new)
library(uc511)
library(uc511)
# NEW-ONE
n <- 337
hf_ <- uc511::HaltonFrame(n = n,
J = c(3, 2),
bases = c(2, 3),
shapefile = shp.ashb,
crs = 4167)
diff_ <- hf_$diff_
pts.shp <- hf_$pts.shp
bb <- hf_$bb
# Plot elements.
plot(sf::st_geometry(shp.ashb))
plot(sf::st_geometry(bb), add = TRUE)
plot(sf::st_geometry(pts.shp), add = T, col= "red", pch = 16)
plot(sf::st_geometry(diff_), add = T, col= "green", pch = 16)
hf_$J
hf_$halton_frame
# create/update files in man directory
devtools::document()
library(pkgdown)
pkgdown::build_site()
set.seed(1)
# define HIP parameters.
pop <- matrix(runif(5000*2), nrow = 5000, ncol = 2)
n <- 20
its <- 7
# generate HIP sample.
result <- uc511::HIP(population = pop, n = n, iterations = its)
dim(pop)
dim(pop)[2]
length(dim(pop))
library(uc511)
set.seed(1)
# define HIP parameters.
pop <- matrix(runif(5000*2), nrow = 5000, ncol = 2)
n <- 20
its <- 7
# generate HIP sample.
result <- uc511::HIP(population = pop, n = n, iterations = its)
dim(parm_value)
parm_value
nrow(parm_value)
length(parm_value)
typeof(parm_value)
x <- parm_value[1]
set.seed(1)
# define HIP parameters.
pop <- matrix(runif(5000*2), nrow = 5000, ncol = 2)
library(uc511)
n <- 20
its <- 7
# generate HIP sample.
result <- uc511::HIP(population = pop, n = n, iterations = its)
# HaltonIndex
HaltonIndex <- result$HaltonIndex
table(HaltonIndex)
library(uc511)
library(uc511)
pop <- matrix(runif(500000*2), nrow = 500000, ncol = 2)
typeof(pop)
library(uc511)
set.seed(1)
pop <- matrix(runif(500000*2), nrow = 500000, ncol = 2)
n <- 200
its <- 7
res <- uc511::HIP(population = pop, n = n, iterations =  its)
HaltonIndex <- res$HaltonIndex
table(HaltonIndex)
set.seed(1110)
pop <- matrix(runif(500*2), nrow = 500, ncol = 2)
n <- 36
its <- 3
res <- uc511::HIP(population = pop, n = n, iterations =  its)
HaltonIndex <- res$HaltonIndex
table(HaltonIndex)
# Convert the matrix to an sf point object
sf_points <- sf::st_as_sf(data.frame(pop), coords = c("X1", "X2"))
sf_points
res <- uc511::HIP(population = pop, n = n, iterations =  its)
HaltonIndex <- res$HaltonIndex
table(HaltonIndex)
res <- uc511::HIP(population = sf_points, n = n, iterations =  its)
inherits(sf_points, "sf")
inherits(sf_points$geometry, "POINT")
sf_points$geometry
sf_points$geometry
inherits(sf_points$geometry, "POINTS")
inherits(sf_points$geometry, "POINT")
sf::st_geometry(sf_points)
is(sf::st_geometry(sf_points), "POINT")
is(sf::st_geometry(sf_points), "sfc_POINT")
inherits(sf_points$geometry, "sfc_POINT")
library(uc511)
set.seed(1110)
pop <- matrix(runif(500*2), nrow = 500, ncol = 2)
n <- 36
its <- 3
# Convert the matrix to an sf point object
sf_points <- sf::st_as_sf(data.frame(pop), coords = c("X1", "X2"))
res <- uc511::HIP(population = sf_points, n = n, iterations =  its)
sf::st_coordinates(sf_points)
length(sf::st_coordinates(sf_points))
dim(sf::st_coordinates(sf_points))
library(uc511)
set.seed(1110)
pop <- matrix(runif(500*2), nrow = 500, ncol = 2)
n <- 36
its <- 3
# Convert the matrix to an sf point object
sf_points <- sf::st_as_sf(data.frame(pop), coords = c("X1", "X2"))
res <- uc511::HIP(population = sf_points, n = n, iterations =  its)
HaltonIndex <- res$HaltonIndex
table(HaltonIndex)
res$popIndex
res$Order
res$HaltonIndex
length(res$Order)
length(res$HaltonIndex)
length(res$popIndex)
library(uc511)
library(uc511)
shp_file1 <- "/home/phil/uc511shiny/gadm36_NZL_shp/gadm36_NZL_2.shp"
xx1 <- sf::read_sf(shp_file1, stringsAsFactors = TRUE) # read-in shapefile
shp.ashb <- xx1[xx1$NAME_2 == "Ashburton",]
crs <- 4167
# NEW-ONE
n <- 337
hf_ <- uc511::HaltonFrame(n = n,
J = c(3, 2),
bases = c(2, 3),
shapefile = shp.ashb,
crs = crs)
library(uc511)
